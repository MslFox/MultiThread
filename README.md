# MultiThread
:white_check_mark: [Наблюдения к задаче 3](#Наблюдения_к_задаче_3)
____
## Задача 1. Межпоточный диалог
#### Описание
Cоздать (3-4 потока) которые каждые 2-3 секунды отправляют в консоль 
некоторое сообщение, обязательно содержащее имя потока, которое было задано при создании. Поток должен выполнять бесконечный цикл вывода сообщения и сна (задержки). 
Главный поток программы (метод main) должен дать поработать остальным потокам какое-то время (секунд 15), а потом одним методом завершить все созданные ранее потоки.

#### Функционал программы
:white_check_mark: Создание 4 потоков, каждый из которых имеет свое имя. \
:white_check_mark: Каждые 2-3 секунды поток печатает сообщение в консоль. Обязательно в сообщении должно фигурировать имя потока\
:white_check_mark: Через какое-то время (например 15 секунд), главный поток должен одним методом завершить все созданные ранее потоки\
### ***Решение:***
[ MultiThread.Task 1 'Interthread Dialog'](https://github.com/MsLFoxGit/MultiThread/commit/77a24f29279aee61c71ec8e77b47f52e8094209e)
____
## Задача 2. Межпоточный диалог со счетчиком
#### Описание
Модифицируйте код для потоков из предыдущей задачи таким образом, чтобы это была Callable-задача, возвращающая кол-во выведенных в консоль сообщений, 
а цикл выполнения был конечен. Запустите некоторое кол-во этих задач в пул потоков фиксированного количества и получите результаты выполнения задач. 
Проведите аналогичную операцию, но с получением результата от одной из задач (pool.invokeAny())

#### Функционал программы
:white_check_mark: Создание 4 потоков, каждый из которых имеет свое имя.\
:white_check_mark: Каждые 2-3 секунды поток печатает сообщение в консоль. Обязательно в сообщении должно фигурировать имя потока\
### ***Решение:***
[ MultiThread.Task 2 'Interthread Dialog with counter'](https://github.com/MsLFoxGit/MultiThread/commit/ec5efe33d50ff58bf1b386f2a25aae876a6e14b0)
____
## Задача 3. Калькулятор массива
#### Описание
Вам нужно написать программу, которая подсчитывает сумму и среднее арифметическое элементов массива. 
Нужно представить однопоточное и многопоточное решение, а также попытаться сравнить время выполнения обоих решений. 
Для начала, сгенерируйте целочисленный массив большого размера, а затем попробуйте сделать для него расчеты в обоих режимах, фиксируя время. 
Попробуйте изменить количество элементов массива и оценить, насколько эффективнее использовать параллельные расчеты на большом массиве 
и падение эффективности на небольших массивах.
Используйте `ForkJoinPool`

#### Функционал программы
:white_check_mark: Создание заполненного массива целых чисел.\
:white_check_mark: Однопоточный подсчет суммы элементов массива.\
:white_check_mark: Многопоточный подсчет суммы элементов массива.
### ***Решение:***
[MultiThread.Task 3 'ArraySum() ForkJoinPool'](https://github.com/MsLFoxGit/MultiThread/commit/25f62ff153dafa17ba88317d50ddebfc7d01c514)
____
<a name="Наблюдения_к_задаче_3"></a>
### Наблюдения к задаче 3
Без ограничения количества рекурсий(для конкретной задачи), разделение задач работает медленне, чем прямое выполнение в одном потоке.
#### Пример с размером массива  200_000_000:
```
Создание int[200000000].....
Ожидайте.....
Массив создан

Старт streamSum()....
Результат 1000005727
Время выполнения: 0.063сек.

Старт cycleSum()....
Результат 1000005727
Время выполнения: 0.12сек.

Старт recursionSum()....
Результат 1000005727
Время выполнения: 25.014сек.
```
Но при органичении глубины рекурсии количеством активных потоков, в моем случае это `MAX_ACTIVATE_THREADS = 6`
https://github.com/MsLFoxGit/MultiThread/blob/ef108bda8eef0c5b4309584612cf4ea0e8a1d356/src/Netology/Multithread_Functional/Multithread/MyRecursiveTask.java#L7
```
    protected Long compute() {
        if (Thread.activeCount() >= MAX_ACTIVATE_THREADS) {
            return cycleSum();
        }
```
рекурсия стабильно показывает лучшие результаты, начиная с размера массива от 20_000_000\
#### Пример с размером массива  2_000_000_000:
```
Создание int[2000000000].....
Ожидайте.....
Массив создан

Старт streamSum()....
Результат 9999934281
Время выполнения: 0.597сек.

Старт cycleSum()....
Результат 9999934281
Время выполнения: 1.19сек.

Старт recursionSum()....
Результат 9999934281
Время выполнения: 0.33сек.
```
Из примера выше, хорошо видно, что при больших размерах массива, разбиение подсчета на несколько потоков работает, как минимум, в 2 раза быстрее других вариантов подсчета.  
В тоже время при относительно небольшом размере массива "цикл" показывает уверенно лучшие результаты
#### Пример с размером массива  200_000:
```
Создание int[200000].....
Ожидайте.....
Массив создан

Старт streamSum()....
Результат 1000742
Время выполнения: 0.004сек.

Старт cycleSum()....
Результат 1000742
Время выполнения: 0.002сек.

Старт recursionSum()....
Результат 1000742
Время выполнения: 0.006сек.
```
Вывод: Для решения исходной задачи, при использовнии вариантов моей реализации  подсчета суммы, при размере массива более чем 20_000_000 элементов, следует использовать рекурсию и разделение задач.
